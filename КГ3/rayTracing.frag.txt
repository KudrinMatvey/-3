#version 430

in vec3 origin,direction;
out vec4 outputColor;

struct Sphere
{
	vec3 position;
	float radius;
	vec3 color;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct RayNode
{
	Ray ray;
	vec3 color;
	int depth;
};

struct HitInfo
{
	bool hitDetected;
	vec3 hitPoint;
	vec3 surfaceNormal;
	float distance;
};

const int Max_Depth = 5;
const int Max_Nodes = 64;
const int sphereNumber = 2;
Sphere spheres[sphereNumber];
RayNode rayNode[Max_Nodes];

void sphereIntersect(Ray ray, int objectid, inout HitInfo hitInfo)
{
	Sphere sphere = spheres[objectid];
	vec3 trackToSphere = ray.origin - sphere.position;
	float a = dot(ray.direction,ray.direction);
	float b = 2 * dot(trackToSphere,ray.direction);
	float c = dot(trackToSphere, trackToSphere) - sphere.radius * sphere.radius;
	float discriminant = b * b - 4.0 * a * c;

	if( discriminant > 0.0)
	{
		float distance = (- b - sqrt(discriminant)) / (2.0 * a);
		if(distance > 0.0001 && (distance<hitInfo.distance && hitInfo.hitDetected ||  !hitInfo.hitDetected))
		{
			hitInfo.distance = distance;
			hitInfo.hitPoint = ray.origin + ray.direction * hitInfo.distance;
			hitInfo.surfaceNormal = normalize(hitInfo.hitPoint - sphere.position);
			hitInfo.hitDetected = true;
		}
	}
}
vec3 iterativeRayTrace(Ray ray)
{
	spheres[0].position = vec3(0.0,0.0, -1.0);
	spheres[0].radius = 0.5;
	spheres[0].color = vec3(0.9,0.5,0.7);
	int numberOfNodes = 1, currentNodeIndex = 0;
	float cos;
	rayNode[currentNodeIndex].ray = ray;
	rayNode[currentNodeIndex].depth = 0;

	while(currentNodeIndex < numberOfNodes)
	{			
		HitInfo hitInfo;
		hitInfo.hitDetected = false;
		sphereIntersect(ray,0,hitInfo);
		
		if(hitInfo.hitDetected)
		{
		cos = 0.5f;
			cos = (ray.direction.x * hitInfo.surfaceNormal.x + ray.direction.y * hitInfo.surfaceNormal.y + ray.direction.z * hitInfo.surfaceNormal.z + 1) /  
									(sqrt(ray.direction.x * ray.direction.x + ray.direction.y * ray.direction.y + ray.direction.z * ray.direction.z)
									* sqrt(hitInfo.surfaceNormal.x * hitInfo.surfaceNormal.x + hitInfo.surfaceNormal.y * hitInfo.surfaceNormal.y + hitInfo.surfaceNormal.z * hitInfo.surfaceNormal.z));  
		//cos = ray.origin.x * ray.direction.x + ray.origin.y * ray.direction.y + ray.origin.z * ray.direction.z / 
			//						(sqrt(ray.origin.x * ray.origin.x + ray.origin.y * ray.origin.y + ray.origin.z * ray.origin.z) 
				//					* sqrt(ray.direction.x * ray.direction.x + ray.direction.y * ray.direction.y + ray.direction.z * ray.direction.z));  
			
			rayNode[currentNodeIndex].color = vec3(spheres[0].color.x * cos,spheres[0].color.y * cos,spheres[0].color.z * cos);			
		}
		else break;
		currentNodeIndex++;
	}
	return rayNode[0].color;
}
void main()
{
	Ray ray = Ray(origin,direction);
	outputColor = vec4(iterativeRayTrace(ray),1);
}
